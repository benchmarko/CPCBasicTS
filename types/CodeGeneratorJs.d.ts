import { IOutput, ICpcVmRsx } from "./Interfaces";
import { BasicLexer } from "./BasicLexer";
import { BasicParser } from "./BasicParser";
import { Variables } from "./Variables";
interface CodeGeneratorJsOptions {
    lexer: BasicLexer;
    parser: BasicParser;
    rsx: ICpcVmRsx;
    trace?: boolean;
    quiet?: boolean;
    noCodeFrame?: boolean;
}
export declare class CodeGeneratorJs {
    private readonly lexer;
    private readonly parser;
    private readonly rsx;
    private trace;
    private quiet;
    private readonly noCodeFrame;
    private line;
    private traceActive;
    private readonly reJsKeywords;
    private readonly stack;
    private gosubCount;
    private ifCount;
    private stopCount;
    private forCount;
    private whileCount;
    private referencedLabelsCount;
    private readonly dataList;
    private readonly labelList;
    private sourceMap;
    private countMap;
    private variables;
    private defScopeArgs?;
    private defintDefstrTypes;
    constructor(options: CodeGeneratorJsOptions);
    private static readonly jsKeywords;
    private reset;
    private resetCountsPerLine;
    private composeError;
    private static createJsKeywordRegex;
    private fnDeclareVariable;
    private static varTypeMap;
    private fnAdaptVariableName;
    private fnParseOneArg;
    private fnParseArgRange;
    private fnParseArgs;
    private fnDetermineStaticVarType;
    private static fnExtractVarName;
    private static fnGetNameTypeExpression;
    private static fnIsIntConst;
    private static fnGetRoundString;
    private static fnIsInString;
    private fnPropagateStaticTypes;
    private plus;
    private minus;
    private mult;
    private div;
    private intDiv;
    private exponent;
    private and;
    private or;
    private xor;
    private static not;
    private mod;
    private greater;
    private less;
    private greaterEqual;
    private lessEqual;
    private equal;
    private notEqual;
    private addressOf;
    private static stream;
    private allOperators;
    private unaryOperators;
    private fnParseDefIntRealStr;
    private fnAddReferenceLabel;
    private fnGetForLabel;
    private fnGetGosubLabel;
    private fnGetIfLabel;
    private fnGetStopLabel;
    private fnGetWhileLabel;
    private fnCommandWithGoto;
    private static commaOrSemicolon;
    private vertical;
    private static number;
    private static expnumber;
    private static binnumber;
    private static hexnumber;
    private identifier;
    private static letter;
    private static linenumber;
    private range;
    private linerange;
    private static string;
    private static unquoted;
    private static fnNull;
    private assign;
    private generateTraceLabel;
    private label;
    private afterEveryGosub;
    private static cont;
    private data;
    private def;
    private dim;
    private "delete";
    private edit;
    private "else";
    private erase;
    private error;
    private fn;
    private "for";
    private gosub;
    private gotoOrResume;
    private fnThenOrElsePart;
    private static fnIsSimplePart;
    private "if";
    private inputOrlineInput;
    private let;
    private list;
    private mid$Assign;
    private static "new";
    private next;
    private onBreakGosubOrRestore;
    private onErrorGoto;
    private onGosubOnGoto;
    private onSqGosub;
    private print;
    private randomize;
    private read;
    private rem;
    private static "return";
    private run;
    private save;
    private spc;
    private stopOrEnd;
    private tab;
    private wend;
    private "while";
    private readonly parseFunctions;
    private fnParseOther;
    private parseNode;
    private static fnCommentUnusedCases;
    private fnCreateLabelsMap;
    private removeAllDefVarTypes;
    private fnSetDefVarTypeRange;
    private fnPrecheckDefintDefstr;
    private fnPrecheckTree;
    private evaluate;
    private static combineData;
    private static combineLabels;
    getSourceMap(): Record<string, number[]>;
    debugGetLabelsCount(): number;
    generate(input: string, variables: Variables, allowDirect?: boolean): IOutput;
}
export {};
//# sourceMappingURL=CodeGeneratorJs.d.ts.map