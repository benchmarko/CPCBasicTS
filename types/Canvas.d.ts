declare type CharType = number[];
declare type CharsetType = CharType[];
export interface CanvasOptions {
    charset: CharsetType;
    onClickKey?: (arg0: string) => void;
}
export declare class Canvas {
    private readonly options;
    private readonly fnUpdateCanvasHandler;
    private readonly fnUpdateCanvas2Handler;
    private fps;
    private readonly cpcAreaBox;
    private customCharset;
    private gColMode;
    private mask;
    private maskBit;
    private maskFirst;
    private offset;
    private readonly canvas;
    private width;
    private height;
    private borderWidth;
    private readonly dataset8;
    private needUpdate;
    private readonly colorValues;
    private readonly currentInks;
    private readonly speedInk;
    private inkSet;
    private readonly pen2ColorMap;
    private animationTimeoutId?;
    private animationFrame?;
    private readonly ctx;
    private readonly imageData;
    private fnCopy2Canvas?;
    private littleEndian;
    private pen2Color32?;
    private data32?;
    private use32BitCopy;
    private gPen;
    private gPaper;
    private speedInkCount;
    private hasFocus;
    private mode;
    private modeData;
    private xPos;
    private yPos;
    private xOrig;
    private yOrig;
    private xLeft;
    private xRight;
    private yTop;
    private yBottom;
    private gTransparent;
    constructor(options: CanvasOptions);
    private static readonly colors;
    private static readonly defaultInks;
    private static readonly modeData;
    reset(): void;
    resetCustomChars(): void;
    private static isLittleEndian;
    private static extractColorValues;
    private static extractAllColorValues;
    private setAlpha;
    private setNeedUpdate;
    private updateCanvas2;
    private updateCanvas;
    startUpdateCanvas(): void;
    stopUpdateCanvas(): void;
    private copy2Canvas8bit;
    private copy2Canvas32bit;
    private copy2Canvas32bitWithOffset;
    private applyCopy2CanvasFunction;
    setScreenOffset(offset: number): void;
    private updateColorMap;
    updateSpeedInk(): void;
    setCustomChar(char: number, charData: CharType): void;
    getCharData(char: number): CharType;
    setDefaultInks(): void;
    private setFocusOnCanvas;
    private getMousePos;
    private canvasClickAction2;
    onCpcCanvasClick(event: MouseEvent): void;
    onWindowClick(_event: Event): void;
    getXpos(): number;
    getYpos(): number;
    private fillMyRect;
    fillTextBox(left: number, top: number, width: number, height: number, paper: number): void;
    private moveMyRectUp;
    private moveMyRectDown;
    private invertChar;
    private setChar;
    private readCharData;
    private setSubPixels;
    private setPixel;
    private setPixelOriginIncluded;
    private testSubPixel;
    private testPixel;
    getByte(addr: number): number | null;
    setByte(addr: number, byte: number): void;
    private drawBresenhamLine;
    draw(x: number, y: number): void;
    move(x: number, y: number): void;
    plot(x: number, y: number): void;
    test(x: number, y: number): number;
    setInk(pen: number, ink1: number, ink2: number): boolean;
    setBorder(ink1: number, ink2: number): void;
    setGPen(gPen: number): void;
    setGPaper(gPaper: number): void;
    setGTransparentMode(transparent: boolean): void;
    printGChar(char: number): void;
    printChar(char: number, x: number, y: number, pen: number, paper: number, transparent: boolean): void;
    drawCursor(x: number, y: number, pen: number, paper: number): void;
    private findMatchingChar;
    readChar(x: number, y: number, pen: number, paper: number): number;
    private fnIsNotInWindow;
    fill(fillPen: number): void;
    private static fnPutInRange;
    setOrigin(xOrig: number, yOrig: number): void;
    setGWindow(xLeft: number, xRight: number, yTop: number, yBottom: number): void;
    setGColMode(gColMode: number): void;
    clearTextWindow(left: number, right: number, top: number, bottom: number, paper: number): void;
    clearGraphicsWindow(): void;
    clearFullWindow(): void;
    windowScrollUp(left: number, right: number, top: number, bottom: number, paper: number): void;
    windowScrollDown(left: number, right: number, top: number, bottom: number, paper: number): void;
    setSpeedInk(time1: number, time2: number): void;
    setMask(mask: number): void;
    setMaskFirst(maskFirst: number): void;
    getMode(): number;
    changeMode(mode: number): void;
    setMode(mode: number): void;
    getCanvasElement(): HTMLCanvasElement;
}
export {};
//# sourceMappingURL=Canvas.d.ts.map