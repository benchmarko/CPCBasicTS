import { IOutput, ICpcVmRsx } from "./Interfaces";
import { BasicLexer } from "./BasicLexer";
import { BasicParser, ParserNode } from "./BasicParser";
import { Variables } from "./Variables";
interface CodeGeneratorJsOptions {
    lexer: BasicLexer;
    parser: BasicParser;
    rsx: ICpcVmRsx;
    tron: boolean;
    bQuiet?: boolean;
    bNoCodeFrame?: boolean;
}
interface CodeNode extends ParserNode {
    left?: CodeNode;
    right?: CodeNode;
    args: CodeNode[];
    pt: string;
    pv: string;
}
export declare class CodeGeneratorJs {
    private lexer;
    private parser;
    private tron;
    private rsx;
    private bQuiet;
    private bNoCodeFrame;
    private iLine;
    private reJsKeywords;
    private oStack;
    private aData;
    private oLabels;
    private bMergeFound;
    private iGosubCount;
    private iIfCount;
    private iStopCount;
    private iForCount;
    private iWhileCount;
    private oVariables;
    private oDefScopeArgs?;
    constructor(options: CodeGeneratorJsOptions);
    private static aJsKeywords;
    private reset;
    private resetCountsPerLine;
    private composeError;
    private static createJsKeywordRegex;
    private fnDeclareVariable;
    private fnAdaptVariableName;
    private fnParseOneArg;
    private fnParseArgRange;
    private fnParseArgs;
    private fnDetermineStaticVarType;
    private static fnIsIntConst;
    private static fnGetRoundString;
    private static fnIsInString;
    private fnPropagateStaticTypes;
    private plus;
    private minus;
    private mult;
    private div;
    private intDiv;
    private exponent;
    private and;
    private or;
    private xor;
    private static not;
    private mod;
    private greater;
    private less;
    private greaterEqual;
    private lessEqual;
    private equal;
    private notEqual;
    private addressOf;
    private static stream;
    private mOperators;
    private fnParseDefIntRealStr;
    private fnParseErase;
    private fnAddReferenceLabel;
    private fnCommandWithGoto;
    private static semicolon;
    private static comma;
    private vertical;
    private static number;
    private static binnumber;
    private static hexnumber;
    private static linenumber;
    private identifier;
    private static letter;
    private range;
    private linerange;
    private static string;
    private static unquoted;
    private static fnNull;
    private assign;
    private label;
    private afterGosub;
    private call;
    private chain;
    private chainMerge;
    private clear;
    private closeout;
    private static cont;
    private data;
    private def;
    private defint;
    private defreal;
    private defstr;
    private dim;
    private "delete";
    private edit;
    private "else";
    private end;
    private erase;
    private error;
    private everyGosub;
    private fn;
    private "for";
    private frame;
    private gosub;
    private "goto";
    private "if";
    private input;
    private let;
    private lineInput;
    private list;
    private load;
    private merge;
    private mid$Assign;
    private static "new";
    private next;
    private onBreakGosub;
    private onErrorGoto;
    private onGosub;
    private onGoto;
    private onSqGosub;
    private openin;
    private print;
    private randomize;
    private read;
    private rem;
    private renum;
    private restore;
    private resume;
    private static "return";
    private run;
    private save;
    private sound;
    private spc;
    private stop;
    private tab;
    private wend;
    private "while";
    mParseFunctions: {
        [k in string]: (node: CodeNode) => string;
    };
    private fnParseOther;
    private parseNode;
    private static fnCommentUnusedCases;
    private fnCreateLabelsMap;
    private evaluate;
    private static combineData;
    debugGetLabelsCount(): number;
    generate(sInput: string, oVariables: Variables, bAllowDirect?: boolean): IOutput;
}
export {};
