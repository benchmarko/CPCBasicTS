import { IOutput, ICpcVmRsx } from "./Interfaces";
import { BasicLexer } from "./BasicLexer";
import { BasicParser, ParserNode } from "./BasicParser";
import { Variables } from "./Variables";
interface CodeGeneratorJsOptions {
    lexer: BasicLexer;
    parser: BasicParser;
    rsx: ICpcVmRsx;
    tron: boolean;
    bQuiet?: boolean;
    bNoCodeFrame?: boolean;
}
interface CodeNode extends ParserNode {
    left?: CodeNode;
    right?: CodeNode;
    pt: string;
    pv: string;
}
declare type StringArray = string[];
export declare class CodeGeneratorJs {
    lexer: BasicLexer;
    parser: BasicParser;
    tron: boolean;
    rsx: ICpcVmRsx;
    bQuiet: boolean;
    bNoCodeFrame: boolean;
    iLine: number;
    reJsKeywords: RegExp;
    oStack: {
        forLabel: StringArray;
        forVarName: StringArray;
        whileLabel: StringArray;
    };
    aData: StringArray;
    oLabels: {};
    bMergeFound: boolean;
    iGosubCount: number;
    iIfCount: number;
    iStopCount: number;
    iForCount: number;
    iWhileCount: number;
    parseTree: ParserNode[];
    oVariables: Variables;
    oDevScopeArgs: {
        [k: string]: boolean;
    };
    bDevScopeArgsCollect: boolean;
    static aJsKeywords: string[];
    constructor(options: CodeGeneratorJsOptions);
    init(options: CodeGeneratorJsOptions): void;
    reset(): void;
    private resetCountsPerLine;
    private composeError;
    private static createJsKeywordRegex;
    private fnDeclareVariable;
    private fnAdaptVariableName;
    private fnParseOneArg;
    private fnParseArgRange;
    private fnParseArgs;
    private fnDetermineStaticVarType;
    private static fnIsIntConst;
    private static fnGetRoundString;
    private static fnIsInString;
    private fnPropagateStaticTypes;
    private plus;
    private minus;
    private mult;
    private div;
    private intDiv;
    private exponent;
    private and;
    private or;
    private xor;
    private static not;
    private mod;
    private greater;
    private less;
    private greaterEqual;
    private lessEqual;
    private equal;
    private notEqual;
    private addressOf;
    private static stream;
    mOperators: {
        "+": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "-": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "*": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "/": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "\\": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "^": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        and: (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        or: (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        xor: (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        not: typeof CodeGeneratorJs.not;
        mod: (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        ">": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "<": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        ">=": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "<=": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "=": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "<>": (node: CodeNode, oLeft: CodeNode, oRight: CodeNode) => string;
        "@": (node: CodeNode, oRight: CodeNode) => string;
        "#": typeof CodeGeneratorJs.stream;
    };
    private fnParseDefIntRealStr;
    private fnParseErase;
    private fnAddReferenceLabel;
    private fnCommandWithGoto;
    private static semicolon;
    private static comma;
    private vertical;
    private static number;
    private static binnumber;
    private static hexnumber;
    private static linenumber;
    private identifier;
    private static letter;
    private range;
    private linerange;
    private static string;
    private static fnNull;
    private assign;
    private label;
    private afterGosub;
    private call;
    private chain;
    private chainMerge;
    private clear;
    private closeout;
    private static cont;
    private data;
    private def;
    private defint;
    private defreal;
    private defstr;
    private dim;
    private "delete";
    private edit;
    private static "else";
    private end;
    private erase;
    private error;
    private everyGosub;
    private fn;
    private "for";
    private frame;
    private gosub;
    private "goto";
    private "if";
    private input;
    private let;
    private lineInput;
    private list;
    private load;
    private merge;
    private mid$Assign;
    private static "new";
    private next;
    private onBreakGosub;
    private onErrorGoto;
    private onGosub;
    private onGoto;
    private onSqGosub;
    private openin;
    private print;
    private randomize;
    private read;
    private rem;
    private renum;
    private restore;
    private resume;
    private static "return";
    private run;
    private save;
    private sound;
    private spc;
    private stop;
    private tab;
    private wend;
    private "while";
    mParseFunctions: {
        ";": typeof CodeGeneratorJs.semicolon;
        ",": typeof CodeGeneratorJs.comma;
        "|": (node: CodeNode) => string;
        number: typeof CodeGeneratorJs.number;
        binnumber: typeof CodeGeneratorJs.binnumber;
        hexnumber: typeof CodeGeneratorJs.hexnumber;
        linenumber: typeof CodeGeneratorJs.linenumber;
        identifier: (node: CodeNode) => string;
        letter: typeof CodeGeneratorJs.letter;
        range: (node: CodeNode) => string;
        linerange: (node: CodeNode) => string;
        string: typeof CodeGeneratorJs.string;
        null: typeof CodeGeneratorJs.fnNull;
        assign: (node: CodeNode) => string;
        label: (node: CodeNode) => string;
        afterGosub: (node: CodeNode) => string;
        call: (node: CodeNode) => string;
        chain: (node: CodeNode) => string;
        chainMerge: (node: CodeNode) => string;
        clear: (node: CodeNode) => string;
        closeout: (node: CodeNode) => string;
        cont: typeof CodeGeneratorJs.cont;
        data: (node: CodeNode) => string;
        def: (node: CodeNode) => string;
        defint: (node: CodeNode) => string;
        defreal: (node: CodeNode) => string;
        defstr: (node: CodeNode) => string;
        dim: (node: CodeNode) => string;
        delete: (node: CodeNode) => string;
        edit: (node: CodeNode) => string;
        else: typeof CodeGeneratorJs.else;
        end: (node: CodeNode) => string;
        erase: (node: CodeNode) => string;
        error: (node: CodeNode) => string;
        everyGosub: (node: CodeNode) => string;
        fn: (node: CodeNode) => string;
        for: (node: CodeNode) => string;
        frame: (node: CodeNode) => string;
        gosub: (node: CodeNode) => string;
        goto: (node: CodeNode) => string;
        if: (node: CodeNode) => string;
        input: (node: CodeNode) => string;
        let: (node: CodeNode) => string;
        lineInput: (node: CodeNode) => string;
        list: (node: CodeNode) => string;
        load: (node: CodeNode) => string;
        merge: (node: CodeNode) => string;
        mid$Assign: (node: CodeNode) => string;
        new: typeof CodeGeneratorJs.new;
        next: (node: CodeNode) => string;
        onBreakGosub: (node: CodeNode) => string;
        onErrorGoto: (node: CodeNode) => string;
        onGosub: (node: CodeNode) => string;
        onGoto: (node: CodeNode) => string;
        onSqGosub: (node: CodeNode) => string;
        openin: (node: CodeNode) => string;
        print: (node: CodeNode) => string;
        randomize: (node: CodeNode) => string;
        read: (node: CodeNode) => string;
        rem: (node: CodeNode) => string;
        renum: (node: CodeNode) => string;
        restore: (node: CodeNode) => string;
        resume: (node: CodeNode) => string;
        return: typeof CodeGeneratorJs.return;
        run: (node: CodeNode) => string;
        save: (node: CodeNode) => string;
        sound: (node: CodeNode) => string;
        spc: (node: CodeNode) => string;
        stop: (node: CodeNode) => string;
        tab: (node: CodeNode) => string;
        wend: (node: CodeNode) => string;
        while: (node: CodeNode) => string;
    };
    private fnParseOther;
    private parseNode;
    private static fnCommentUnusedCases;
    private fnCreateLabelsMap;
    private evaluate;
    generate(sInput: string, oVariables: Variables, bAllowDirect?: boolean): IOutput;
}
export {};
