import { BasicLexer } from "./BasicLexer";
import { BasicParser, ParserNode } from "./BasicParser";
import { IOutput } from "./Interfaces";
interface CodeGeneratorBasicOptions {
    lexer: BasicLexer;
    parser: BasicParser;
}
export declare class CodeGeneratorBasic {
    static mCombinedKeywords: {
        chainMerge: string;
        clearInput: string;
        graphicsPaper: string;
        graphicsPen: string;
        keyDef: string;
        lineInput: string;
        mid$Assign: string;
        onBreakCont: string;
        onBreakGosub: string;
        onBreakStop: string;
        onErrorGoto: string;
        resumeNext: string;
        speedInk: string;
        speedKey: string;
        speedWrite: string;
        symbolAfter: string;
        windowSwap: string;
    };
    lexer: BasicLexer;
    parser: BasicParser;
    constructor(options: CodeGeneratorBasicOptions);
    private composeError;
    private fnParseOneArg;
    private fnParseArgs;
    private static mOperators;
    private static mOperatorPrecedence;
    private static fnDecodeEscapeSequence;
    private static string;
    private static fnNull;
    private assign;
    private static number;
    private static binnumber;
    private static hexnumber;
    private identifier;
    private static linenumber;
    private label;
    private vertical;
    private afterGosub;
    private chainMerge;
    private data;
    private def;
    private static "else";
    private ent;
    private env;
    private everyGosub;
    private fn;
    private "for";
    private "if";
    private input;
    private lineInput;
    private list;
    private mid$Assign;
    private onGosub;
    private onGoto;
    private onSqGosub;
    private print;
    private rem;
    private using;
    mParseFunctions: {
        string: typeof CodeGeneratorBasic.string;
        null: typeof CodeGeneratorBasic.fnNull;
        assign: (node: ParserNode) => string;
        number: typeof CodeGeneratorBasic.number;
        binnumber: typeof CodeGeneratorBasic.binnumber;
        hexnumber: typeof CodeGeneratorBasic.hexnumber;
        identifier: (node: ParserNode) => string;
        linenumber: typeof CodeGeneratorBasic.linenumber;
        label: (node: ParserNode) => string;
        "|": (node: ParserNode) => string;
        afterGosub: (node: ParserNode) => string;
        chainMerge: (node: ParserNode) => string;
        data: (node: ParserNode) => string;
        def: (node: ParserNode) => string;
        else: typeof CodeGeneratorBasic.else;
        ent: (node: ParserNode) => string;
        env: (node: ParserNode) => string;
        everyGosub: (node: ParserNode) => string;
        fn: (node: ParserNode) => string;
        for: (node: ParserNode) => string;
        if: (node: ParserNode) => string;
        input: (node: ParserNode) => any;
        lineInput: (node: ParserNode) => any;
        list: (node: ParserNode) => string;
        mid$Assign: (node: ParserNode) => string;
        onGosub: (node: ParserNode) => string;
        onGoto: (node: ParserNode) => string;
        onSqGosub: (node: ParserNode) => string;
        print: (node: ParserNode) => string;
        rem: (node: ParserNode) => string;
        using: (node: ParserNode) => string;
    };
    private fnParseOther;
    private parseNode;
    private evaluate;
    generate(sInput: string, bAllowDirect?: boolean): IOutput;
}
export {};
