import { BasicLexer } from "./BasicLexer";
import { BasicParser, ParserNode } from "./BasicParser";
import { IOutput } from "./Interfaces";
interface CodeGeneratorBasicOptions {
    lexer: BasicLexer;
    parser: BasicParser;
}
export declare class CodeGeneratorBasic {
    static mCombinedKeywords: {
        chainMerge: string;
        clearInput: string;
        graphicsPaper: string;
        graphicsPen: string;
        keyDef: string;
        lineInput: string;
        mid$Assign: string;
        onBreakCont: string;
        onBreakGosub: string;
        onBreakStop: string;
        onErrorGoto: string;
        resumeNext: string;
        speedInk: string;
        speedKey: string;
        speedWrite: string;
        symbolAfter: string;
        windowSwap: string;
    };
    lexer: BasicLexer;
    parser: BasicParser;
    constructor(options: CodeGeneratorBasicOptions);
    init(options: CodeGeneratorBasicOptions): void;
    reset(): void;
    private composeError;
    private fnParseOneArg;
    private fnParseArgs;
    static mOperators: {
        "+": string;
        "-": string;
        "*": string;
        "/": string;
        "\\": string;
        "^": string;
        and: string;
        or: string;
        xor: string;
        not: string;
        mod: string;
        ">": string;
        "<": string;
        ">=": string;
        "<=": string;
        "=": string;
        "<>": string;
        "@": string;
        "#": string;
    };
    static mOperatorPrecedence: {
        "@": number;
        "^": number;
        "p-": number;
        "p+": number;
        "*": number;
        "/": number;
        "\\": number;
        mod: number;
        "+": number;
        "-": number;
        "=": number;
        "<>": number;
        "<": number;
        "<=": number;
        ">": number;
        ">=": number;
        not: number;
        and: number;
        or: number;
        xor: number;
        "#": number;
    };
    private static fnDecodeEscapeSequence;
    private static string;
    private static fnNull;
    private assign;
    private static number;
    private static binnumber;
    private static hexnumber;
    private identifier;
    private static linenumber;
    private label;
    private vertical;
    private afterGosub;
    private chainMerge;
    private data;
    private def;
    private static "else";
    private ent;
    private env;
    private everyGosub;
    private fn;
    private "for";
    private "if";
    private input;
    private lineInput;
    private list;
    private mid$Assign;
    private onGosub;
    private onGoto;
    private onSqGosub;
    private print;
    private rem;
    private using;
    mParseFunctions: {
        string: typeof CodeGeneratorBasic.string;
        null: typeof CodeGeneratorBasic.fnNull;
        assign: (node: ParserNode) => string;
        number: typeof CodeGeneratorBasic.number;
        binnumber: typeof CodeGeneratorBasic.binnumber;
        hexnumber: typeof CodeGeneratorBasic.hexnumber;
        identifier: (node: ParserNode) => string;
        linenumber: typeof CodeGeneratorBasic.linenumber;
        label: (node: ParserNode) => string;
        "|": (node: ParserNode) => string;
        afterGosub: (node: ParserNode) => string;
        chainMerge: (node: ParserNode) => string;
        data: (node: ParserNode) => string;
        def: (node: ParserNode) => string;
        else: typeof CodeGeneratorBasic.else;
        ent: (node: ParserNode) => string;
        env: (node: ParserNode) => string;
        everyGosub: (node: ParserNode) => string;
        fn: (node: ParserNode) => string;
        for: (node: ParserNode) => string;
        if: (node: ParserNode) => string;
        input: (node: ParserNode) => any;
        lineInput: (node: ParserNode) => any;
        list: (node: ParserNode) => string;
        mid$Assign: (node: ParserNode) => string;
        onGosub: (node: ParserNode) => any;
        onGoto: (node: ParserNode) => any;
        onSqGosub: (node: ParserNode) => string;
        print: (node: ParserNode) => string;
        rem: (node: ParserNode) => any;
        using: (node: ParserNode) => string;
    };
    private fnParseOther;
    private parseNode;
    private evaluate;
    generate(sInput: string, bAllowDirect?: boolean): IOutput;
}
export {};
