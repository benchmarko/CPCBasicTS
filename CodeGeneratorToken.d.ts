import { BasicLexer } from "./BasicLexer";
import { BasicParser, ParserNode } from "./BasicParser";
import { IOutput } from "./Interfaces";
interface CodeGeneratorTokenOptions {
    lexer: BasicLexer;
    parser: BasicParser;
}
export declare class CodeGeneratorToken {
    private lexer;
    private parser;
    private iLine;
    private sStatementSeparator;
    constructor(options: CodeGeneratorTokenOptions);
    private static mOperators;
    private static mOperatorPrecedence;
    private static mTokens;
    private static mTokensFF;
    private composeError;
    private static convUInt8ToString;
    private static convUInt16ToString;
    private static convInt32ToString;
    private static token2String;
    private static getBit7TerminatedString;
    private combineArgsWithSeparator;
    private fnParseOneArg;
    private fnParseArgs;
    private fnArgs;
    private static semicolon;
    private colon;
    private static letter;
    private range;
    private linerange;
    private fnParenthesisOpen;
    private static string;
    private static unquoted;
    private static fnNull;
    private assign;
    private static floatToByteString;
    private static number;
    private static binnumber;
    private static hexnumber;
    private identifier;
    private static linenumber;
    private label;
    private vertical;
    private afterGosub;
    private chainMerge;
    private data;
    private def;
    private "else";
    private ent;
    private env;
    private everyGosub;
    private fn;
    private "for";
    private "if";
    private static fnHasStream;
    private input;
    private lineInput;
    private list;
    private mid$Assign;
    private onErrorGoto;
    private onGosub;
    private onGoto;
    private onSqGosub;
    private print;
    private rem;
    private using;
    mParseFunctions: {
        [k: string]: (node: ParserNode) => string;
    };
    private fnParseOther;
    private parseNode;
    private evaluate;
    generate(sInput: string, bAllowDirect?: boolean): IOutput;
}
export {};
