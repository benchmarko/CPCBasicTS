export interface CanvasOptions {
    aCharset: number[][];
    onClickKey?: (arg0: string) => void;
}
interface ModeData {
    iPens: number;
    iPixelWidth: number;
    iPixelHeight: number;
}
export declare class Canvas {
    fnUpdateCanvasHandler: () => void;
    fnUpdateCanvas2Handler: () => void;
    iFps: number;
    cpcAreaBox: HTMLElement;
    textText: HTMLTextAreaElement;
    aCharset: number[][];
    oCustomCharset: {
        [k: number]: number[];
    };
    onClickKey?: (arg0: string) => void;
    iGColMode: number;
    iMask: number;
    iMaskBit: number;
    iMaskFirst: number;
    iOffset: number;
    canvas: HTMLCanvasElement;
    iWidth: number;
    iHeight: number;
    iBorderWidth: number;
    dataset8: Uint8Array;
    bNeedUpdate: boolean;
    bNeedTextUpdate: boolean;
    aColorValues: number[][];
    aCurrentInks: number[][];
    aSpeedInk: number[];
    iInkSet: number;
    aPen2ColorMap: number[][];
    iAnimationTimeoutId: number;
    iAnimationFrame: number;
    imageData: ImageData;
    fnCopy2Canvas: () => void;
    bLittleEndian: boolean;
    aPen2Color32: Uint32Array;
    aData32: Uint32Array;
    bUse32BitCopy: boolean;
    iGPen: number;
    iGPaper: number;
    iSpeedInkCount: number;
    aTextBuffer: number[][];
    bHasFocus: boolean;
    oModeData: ModeData;
    iMode: number;
    xPos: number;
    yPos: number;
    xOrig: number;
    yOrig: number;
    xLeft: number;
    xRight: number;
    yTop: number;
    yBottom: number;
    bGTransparent: boolean;
    constructor(options: CanvasOptions);
    private static aColors;
    private static aDefaultInks;
    private static aModeData;
    private static sCpc2Unicode;
    init(options: CanvasOptions): void;
    reset(): void;
    resetCustomChars(): void;
    private resetTextBuffer;
    static isLittleEndian(): boolean;
    static extractColorValues(sColor: string): number[];
    static extractAllColorValues(aColors: string[]): number[][];
    private setAlpha;
    private setNeedUpdate;
    private setNeedTextUpdate;
    private updateCanvas2;
    private updateCanvas;
    startUpdateCanvas(): void;
    stopUpdateCanvas(): void;
    private copy2Canvas8bit;
    private copy2Canvas32bit;
    private copy2Canvas32bitWithOffset;
    private applyCopy2CanvasFunction;
    setScreenOffset(iOffset: number): void;
    private updateTextWindow;
    private updateColorMap;
    updateSpeedInk(): void;
    setCustomChar(iChar: number, aCharData: number[]): void;
    getCharData(iChar: number): number[];
    setDefaultInks(): void;
    private setFocusOnCanvas;
    private getMousePos;
    private canvasClickAction2;
    onCpcCanvasClick(event: Event): void;
    onWindowClick(_event: Event): void;
    getXpos(): number;
    getYpos(): number;
    private fillMyRect;
    fillTextBox(iLeft: number, iTop: number, iWidth: number, iHeight: number, iPen: number): void;
    private moveMyRectUp;
    private moveMyRectDown;
    private invertChar;
    private setChar;
    private readCharData;
    private setSubPixels;
    private setPixel;
    private setPixelOriginIncluded;
    private testSubPixel;
    private testPixel;
    getByte(iAddr: number): number;
    setByte(iAddr: number, iByte: number): void;
    private drawBresenhamLine;
    draw(x: number, y: number): void;
    drawr(x: number, y: number): void;
    move(x: number, y: number): void;
    mover(x: number, y: number): void;
    plot(x: number, y: number): void;
    plotr(x: number, y: number): void;
    test(x: number, y: number): number;
    testr(x: number, y: number): number;
    setInk(iPen: number, iInk1: number, iInk2: number): boolean;
    setBorder(iInk1: number, iInk2: number): void;
    setGPen(iGPen: number): void;
    setGPaper(iGPaper: number): void;
    setGTransparentMode(bTransparent: boolean): void;
    printGChar(iChar: number): void;
    private clearTextBufferBox;
    private copyTextBufferBoxUp;
    private copyTextBufferBoxDown;
    private putCharInTextBuffer;
    private getCharFromTextBuffer;
    printChar(iChar: number, x: number, y: number, iPen: number, iPaper: number, bTransparent: boolean): void;
    drawCursor(x: number, y: number, iPen: number, iPaper: number): void;
    private findMatchingChar;
    readChar(x: number, y: number, iPen: number, iPaper: number): number;
    fill(iFillPen: number): void;
    private static fnPutInRange;
    setOrigin(xOrig: number, yOrig: number): void;
    setGWindow(xLeft: number, xRight: number, yTop: number, yBottom: number): void;
    setGColMode(iGColMode: number): void;
    clearTextWindow(iLeft: number, iRight: number, iTop: number, iBottom: number, iPaper: number): void;
    clearGraphicsWindow(): void;
    clearFullWindow(): void;
    windowScrollUp(iLeft: number, iRight: number, iTop: number, iBottom: number, iPen: number): void;
    windowScrollDown(iLeft: number, iRight: number, iTop: number, iBottom: number, iPen: number): void;
    setSpeedInk(iTime1: number, iTime2: number): void;
    setMask(iMask: number): void;
    setMaskFirst(iMaskFirst: number): void;
    getMode(): number;
    changeMode(iMode: number): void;
    setMode(iMode: number): void;
}
export {};
