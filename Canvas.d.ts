declare type CharType = number[];
declare type CharsetType = CharType[];
export interface CanvasOptions {
    aCharset: CharsetType;
    onClickKey?: (arg0: string) => void;
}
export declare class Canvas {
    private fnUpdateCanvasHandler;
    private fnUpdateCanvas2Handler;
    private iFps;
    private cpcAreaBox;
    private textText;
    private aCharset;
    private oCustomCharset;
    private onClickKey?;
    private iGColMode;
    private iMask;
    private iMaskBit;
    private iMaskFirst;
    private iOffset;
    private canvas;
    private iWidth;
    private iHeight;
    private iBorderWidth;
    private dataset8;
    private bNeedUpdate;
    private bNeedTextUpdate;
    private aColorValues;
    private aCurrentInks;
    private aSpeedInk;
    private iInkSet;
    private aPen2ColorMap;
    private iAnimationTimeoutId?;
    private iAnimationFrame?;
    private ctx;
    private imageData;
    private fnCopy2Canvas?;
    private bLittleEndian;
    private aPen2Color32?;
    private aData32?;
    private bUse32BitCopy;
    private iGPen;
    private iGPaper;
    private iSpeedInkCount;
    private aTextBuffer;
    private bHasFocus;
    private iMode;
    private oModeData;
    private xPos;
    private yPos;
    private xOrig;
    private yOrig;
    private xLeft;
    private xRight;
    private yTop;
    private yBottom;
    private bGTransparent;
    constructor(options: CanvasOptions);
    private static aColors;
    private static aDefaultInks;
    private static aModeData;
    private static sCpc2Unicode;
    reset(): void;
    resetCustomChars(): void;
    private resetTextBuffer;
    static isLittleEndian(): boolean;
    static extractColorValues(sColor: string): number[];
    static extractAllColorValues(aColors: string[]): number[][];
    private setAlpha;
    private setNeedUpdate;
    private setNeedTextUpdate;
    private updateCanvas2;
    private updateCanvas;
    startUpdateCanvas(): void;
    stopUpdateCanvas(): void;
    private copy2Canvas8bit;
    private copy2Canvas32bit;
    private copy2Canvas32bitWithOffset;
    private applyCopy2CanvasFunction;
    setScreenOffset(iOffset: number): void;
    private updateTextWindow;
    private updateColorMap;
    updateSpeedInk(): void;
    setCustomChar(iChar: number, aCharData: CharType): void;
    getCharData(iChar: number): CharType;
    setDefaultInks(): void;
    private setFocusOnCanvas;
    private getMousePos;
    private canvasClickAction2;
    onCpcCanvasClick(event: MouseEvent): void;
    onWindowClick(_event: Event): void;
    getXpos(): number;
    getYpos(): number;
    private fillMyRect;
    fillTextBox(iLeft: number, iTop: number, iWidth: number, iHeight: number, iPen: number): void;
    private moveMyRectUp;
    private moveMyRectDown;
    private invertChar;
    private setChar;
    private readCharData;
    private setSubPixels;
    private setPixel;
    private setPixelOriginIncluded;
    private testSubPixel;
    private testPixel;
    getByte(iAddr: number): number | null;
    setByte(iAddr: number, iByte: number): void;
    private drawBresenhamLine;
    draw(x: number, y: number): void;
    drawr(x: number, y: number): void;
    move(x: number, y: number): void;
    mover(x: number, y: number): void;
    plot(x: number, y: number): void;
    plotr(x: number, y: number): void;
    test(x: number, y: number): number;
    testr(x: number, y: number): number;
    setInk(iPen: number, iInk1: number, iInk2: number): boolean;
    setBorder(iInk1: number, iInk2: number): void;
    setGPen(iGPen: number): void;
    setGPaper(iGPaper: number): void;
    setGTransparentMode(bTransparent: boolean): void;
    printGChar(iChar: number): void;
    private clearTextBufferBox;
    private copyTextBufferBoxUp;
    private copyTextBufferBoxDown;
    private putCharInTextBuffer;
    private getCharFromTextBuffer;
    printChar(iChar: number, x: number, y: number, iPen: number, iPaper: number, bTransparent: boolean): void;
    drawCursor(x: number, y: number, iPen: number, iPaper: number): void;
    private findMatchingChar;
    readChar(x: number, y: number, iPen: number, iPaper: number): number;
    fill(iFillPen: number): void;
    private static fnPutInRange;
    setOrigin(xOrig: number, yOrig: number): void;
    setGWindow(xLeft: number, xRight: number, yTop: number, yBottom: number): void;
    setGColMode(iGColMode: number): void;
    clearTextWindow(iLeft: number, iRight: number, iTop: number, iBottom: number, iPaper: number): void;
    clearGraphicsWindow(): void;
    clearFullWindow(): void;
    windowScrollUp(iLeft: number, iRight: number, iTop: number, iBottom: number, iPen: number): void;
    windowScrollDown(iLeft: number, iRight: number, iTop: number, iBottom: number, iPen: number): void;
    setSpeedInk(iTime1: number, iTime2: number): void;
    setMask(iMask: number): void;
    setMaskFirst(iMaskFirst: number): void;
    getMode(): number;
    changeMode(iMode: number): void;
    setMode(iMode: number): void;
    startScreenshot(): string;
    getCanvas(): HTMLCanvasElement;
}
export {};
