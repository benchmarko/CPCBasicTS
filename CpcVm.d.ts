import { CustomError } from "./Utils";
import { Keyboard } from "./Keyboard";
import { Random } from "./Random";
import { Sound, SoundData } from "./Sound";
import { Canvas } from "./Canvas";
import { Variables, VariableMap } from "./Variables";
interface CpcVmOptions {
    canvas: Canvas;
    keyboard: Keyboard;
    sound: Sound;
    variables: Variables;
    tron: boolean;
}
interface FileBase {
    bOpen: boolean;
    sCommand: string;
    sName: string;
    iLine: number;
    iStart: number;
    aFileData: string[];
    fnFileCallback: (...aArgs: any[]) => void | boolean;
}
interface InFile extends FileBase {
    iFirst: number;
    iLast: number;
    sMemorizedExample: string;
}
interface OutFile extends FileBase {
    iStream: number;
    sType: string;
    iLength: number;
    iEntry: number;
}
interface WindowDimensions {
    iLeft: number;
    iRight: number;
    iTop: number;
    iBottom: number;
}
interface WindowData extends WindowDimensions {
    iPos: number;
    iVpos: number;
    bTextEnabled: boolean;
    bTag: boolean;
    bTransparent: boolean;
    bCursorOn: boolean;
    bCursorEnabled: boolean;
    iPen: number;
    iPaper: number;
}
interface TimerEntry {
    bActive: boolean;
    iLine: number | string;
    bRepeat: boolean;
    iIntervalMs: number;
    iNextTimeMs: number;
    bHandlerRunning: boolean;
    iStackIndexReturn: number;
    iSavedPriority: number;
}
export interface StopParas {
    iStream?: number;
    sMessage?: string;
    fnInputCallback?: any;
    sInput?: string;
    iLine?: string | number;
    sCommand?: string;
    sNoCRLF?: string;
    aTypes?: string[];
    iFirst?: number;
    iLast?: number;
    iNew?: number;
    iOld?: number;
    iStep?: number;
    iKeep?: number;
    sFileMask?: string;
    sNew?: string;
    sOld?: string;
}
export interface StopEntry {
    sReason: string;
    iPriority: number;
    oParas?: StopParas;
}
export declare class CpcVm {
    fnOpeninHandler: FileBase["fnFileCallback"];
    fnCloseinHandler: () => void;
    fnCloseoutHandler: any;
    fnLoadHandler: any;
    fnRunHandler: any;
    options: CpcVmOptions;
    oCanvas: Canvas;
    oKeyboard: Keyboard;
    oSound: Sound;
    oVariables: Variables;
    tronFlag: boolean;
    oRandom: Random;
    oStop: StopEntry;
    aInputValues: (string | number)[];
    oInFile: InFile;
    oOutFile: OutFile;
    iInkeyTime: number;
    aGosubStack: (number | string)[];
    aMem: number[];
    aData: number[];
    iData: number;
    oDataLineIndex: {
        [k in number]: number;
    };
    aWindow: WindowData[];
    aTimer: TimerEntry[];
    aSqTimer: TimerEntry[];
    aSoundData: SoundData[];
    aCrtcData: number[];
    iCrtcReg: number;
    sPrintControlBuf: string;
    iStartTime: number;
    lastRnd: number;
    iNextFrameTime: number;
    iTimeUntilFrame: number;
    iStopCount: number;
    iLine: string | number;
    iStartLine: number;
    iErrorGotoLine: number;
    iErrorResumeLine: number;
    iBreakGosubLine: number;
    iBreakResumeLine: number;
    sOut: string;
    iErr: number;
    iErl: string | number;
    bDeg: boolean;
    bTron: boolean;
    iTronLine: number;
    iRamSelect: number;
    iScreenPage: number;
    iMinCharHimem: number;
    iMaxCharHimem: number;
    iHimem: number;
    iMinCustomChar: number;
    iTimerPriority: number;
    iZone: number;
    iMode: number;
    iInkeyTimeMs: number;
    rsx: any;
    constructor(options: CpcVmOptions);
    static iFrameTimeMs: number;
    static iTimerCount: number;
    static iSqTimerCount: number;
    static iStreamCount: number;
    static iMinHimem: number;
    static iMaxHimem: number;
    static mWinData: {
        iLeft: number;
        iRight: number;
        iTop: number;
        iBottom: number;
    }[];
    static mUtf8ToCpc: {
        8364: number;
        8218: number;
        402: number;
        8222: number;
        8230: number;
        8224: number;
        8225: number;
        710: number;
        8240: number;
        352: number;
        8249: number;
        338: number;
        381: number;
        8216: number;
        8217: number;
        8220: number;
        8221: number;
        8226: number;
        8211: number;
        8212: number;
        732: number;
        8482: number;
        353: number;
        8250: number;
        339: number;
        382: number;
        376: number;
    };
    private static mControlCodeParameterCount;
    private static aErrors;
    vmInit(options: CpcVmOptions): void;
    vmSetRsxClass(oRsx: any): void;
    vmReset(): void;
    vmResetTimers(): void;
    vmResetWindowData(bResetPenPaper: boolean): void;
    vmResetControlBuffer(): void;
    vmResetFileHandling(oFile: FileBase): void;
    vmResetData(): void;
    vmResetInks(): void;
    vmReset4Run(): void;
    vmGetAllVariables(): VariableMap;
    vmSetStartLine(iLine: any): void;
    vmOnBreakContSet(): boolean;
    vmOnBreakHandlerActive(): number;
    vmEscape(): boolean;
    vmAssertNumber(n: number, sErr: string): void;
    vmAssertString(s: string, sErr: string): void;
    vmRound(n: number, sErr?: string): number;
    vmInRangeRound(n: number, iMin: number, iMax: number, sErr?: string): number;
    vmDetermineVarType(sVarType: string): string;
    vmAssertNumberType(sVarType: string): void;
    vmAssign(sVarType: string, value: string | number): (string | number);
    vmGotoLine(line: string | number, sMsg?: string): void;
    private fnCheckSqTimer;
    private vmCheckTimer;
    private vmCheckTimerHandlers;
    private vmCheckSqTimerHandlers;
    private vmCheckNextFrame;
    vmGetTimeUntilFrame(iTime?: number): number;
    vmLoopCondition(): boolean;
    private vmInitUntypedVariables;
    private vmDefineVarTypes;
    vmStop(sReason: string, iPriority: number, bForce?: boolean, oParas?: StopParas): void;
    vmNotImplemented(sName: string): void;
    private vmUsingFormat1;
    vmGetStopObject(): StopEntry;
    vmGetInFileObject(): InFile;
    vmGetOutFileObject(): OutFile;
    vmAdaptFilename(sName: string, sErr: string): string;
    vmGetSoundData(): SoundData[];
    vmTrace(iLine: any): void;
    private vmDrawMovePlot;
    private vmAfterEveryGosub;
    private vmCopyFromScreen;
    private vmCopyToScreen;
    private vmSetScreenBase;
    private vmSetScreenOffset;
    private vmSetTransparentMode;
    abs(n: number): number;
    addressOf(sVar: string): number;
    afterGosub(iInterval: number, iTimer: number, iLine: number): void;
    private static vmGetCpcCharCode;
    asc(s: string): number;
    atn(n: number): number;
    auto(): void;
    bin$(n: number, iPad?: number): string;
    border(iInk1: number, iInk2?: number): void;
    private vmMcSetMode;
    private vmTxtInverse;
    private vmPutKeyInBuffer;
    call(iAddr: number): void;
    cat(): void;
    chain(sName: string, iLine?: number): void;
    chainMerge(sName: string, iLine?: number, iFirst?: number, iLast?: number): void;
    chr$(n: number): string;
    cint(n: number): number;
    clear(): void;
    clearInput(): void;
    clg(iGPaper?: number): void;
    vmCloseinCallback(): void;
    closein(): void;
    vmCloseoutCallback(): void;
    closeout(): void;
    cls(iStream?: number): void;
    commaTab(iStream: number): string;
    cont(): void;
    copychr$(iStream: number): string;
    cos(n: number): number;
    creal(n: number): number;
    vmPlaceRemoveCursor(iStream: number): void;
    vmDrawUndrawCursor(iStream: number): void;
    cursor(iStream: number, iCursorOn: number | null, iCursorEnabled?: number): void;
    data(iLine: number, ...aArgs: any[]): void;
    dec$(n: number, sFrmt: string): string;
    defint(sNameOrRange: string): void;
    defreal(sNameOrRange: string): void;
    defstr(sNameOrRange: string): void;
    deg(): void;
    "delete"(iFirst?: number | null, iLast?: number): void;
    derr(): number;
    di(): void;
    dim(sVarName: string): void;
    draw(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    drawr(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    edit(iLine: number): void;
    ei(): void;
    end(sLabel: string): void;
    ent(iToneEnv: number, ...aArgs: number[]): void;
    env(iVolEnv: number, ...aArgs: number[]): void;
    eof(): number;
    vmFindArrayVariable(sName: string): string;
    erase(...aArgs: string[]): void;
    erl(): number;
    err(): number;
    vmComposeError(oError: Error, iErr: number, sErrInfo: string): CustomError;
    error(iErr: number, sErrInfo: string): void;
    everyGosub(iInterval: number, iTimer: number, iLine: number): void;
    exp(n: number): number;
    fill(iGPen: number): void;
    fix(n: number): number;
    frame(): void;
    fre(): number;
    gosub(retLabel: string | number, n: number): void;
    "goto"(n: string): void;
    graphicsPaper(iGPaper: number): void;
    graphicsPen(iGPen: number | null, iTransparentMode?: number): void;
    hex$(n: number, iPad?: number): string;
    himem(): number;
    ink(iPen: number, iInk1: number, iInk2?: number): void;
    inkey(iKey: number): number;
    inkey$(): string;
    inp(iPort: number): number;
    vmSetInputValues(aInputValues: (string | number)[]): void;
    vmGetNextInput(): string | number;
    vmInputCallback(): boolean;
    private vmInputNextFileItem;
    vmInputFromFile(aTypes: string[]): void;
    input(iStream: number, sNoCRLF: string, sMsg: string): void;
    instr(p1: string | number, p2: string, p3?: string): number;
    "int"(n: number): number;
    joy(iJoy: number): number;
    key(iToken: number, s: string): void;
    keyDef(iCpcKey: number, iRepeat: number, iNormal?: number | null, iShift?: number | null, iCtrl?: number): void;
    left$(s: string, iLen: number): string;
    len(s: string): number;
    vmLineInputCallback(): boolean;
    lineInput(iStream: number | null, sNoCRLF: string, sMsg: string, sVarType: string): void;
    list(iStream: number | null, iFirst?: number, iLast?: number): void;
    vmLoadCallback(sInput: string, oMeta: any): boolean;
    load(sName: string, iStart?: number): void;
    vmLocate(iStream: number, iPos: number, iVpos: number): void;
    locate(iStream: number, iPos: number, iVpos: number): void;
    log(n: number): number;
    log10(n: number): number;
    lower$(s: string): string;
    mask(iMask: number | null, iFirst?: number): void;
    max(...aArgs: number[]): number;
    memory(n: number): void;
    merge(sName: string): void;
    mid$(s: string, iStart: number, iLen?: number): string;
    mid$Assign(s: string, iStart: number, iLen: number | null, sNew: string): string;
    min(...aArgs: number[]): number;
    mode(iMode: number): void;
    move(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    mover(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    "new"(): void;
    onBreakCont(): void;
    onBreakGosub(iLine: number): void;
    onBreakStop(): void;
    onErrorGoto(iLine: number): void;
    onGosub(retLabel: string, n: number, ...aArgs: number[]): void;
    onGoto(retLabel: string, n: number, ...aArgs: number[]): void;
    private fnChannel2ChannelIndex;
    onSqGosub(iChannel: number, iLine: number): void;
    vmOpeninCallback(sInput: string | null): void;
    openin(sName: string): void;
    openout(sName: string): void;
    origin(xOff: number, yOff: number, xLeft?: number, xRight?: number, yTop?: number, yBottom?: number): void;
    vmSetRamSelect(iBank: number): void;
    vmSetCrtcData(iByte: number): void;
    out(iPort: number, iByte: number): void;
    paper(iStream: number | null, iPaper: number): void;
    vmGetCharDataByte(iAddr: number): number;
    vmSetCharDataByte(iAddr: number, iByte: number): void;
    peek(iAddr: number): number;
    pen(iStream: number, iPen: number | null, iTransparent?: number): void;
    pi(): number;
    plot(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    plotr(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    poke(iAddr: number, iByte: number): void;
    pos(iStream: number): number;
    private vmGetAllowedPosOrVpos;
    private vmMoveCursor2AllowedPos;
    private vmPrintChars;
    private vmControlSymbol;
    private vmControlWindow;
    private vmHandleControlCode;
    private vmPrintCharsOrControls;
    private vmPrintGraphChars;
    print(iStream: number, ...aArgs: any[]): void;
    rad(): void;
    private vmHashCode;
    private vmRandomizeCallback;
    randomize(n?: number): void;
    read(sVarType: string): string | number;
    release(iChannelMask: number): void;
    remain(iTimer: number): number;
    renum(iNew?: number, iOld?: number, iStep?: number, iKeep?: number): void;
    restore(iLine?: number): void;
    resume(iLine: number): void;
    resumeNext(): void;
    "return"(): void;
    right$(s: string, iLen: number): string;
    rnd(n: number): number;
    round(n: number, iDecimals?: number): number;
    private vmRunCallback;
    run(numOrString?: number | string): void;
    save(sName: string, sType?: string, iStart?: number, iLength?: number, iEntry?: number): void;
    sgn(n: number): number;
    sin(n: number): number;
    sound(iState: number, iPeriod: number, iDuration?: number, iVolume?: number, iVolEnv?: number, iToneEnv?: number, iNoise?: number): void;
    space$(n: number): string;
    spc(iStream: number, n: number): string;
    speedInk(iTime1: number, iTime2: number): void;
    speedKey(iDelay: number, iRepeat: number): void;
    speedWrite(n: number): void;
    sq(iChannel: number): number;
    sqr(n: number): number;
    stop(sLabel: string): void;
    str$(n: number): string;
    string$(iLen: number, chr: number | string): string;
    symbol(iChar: number, ...aArgs: number[]): void;
    symbolAfter(iChar: number): void;
    tab(iStream: number, n: number): string;
    tag(iStream?: number): void;
    tagoff(iStream?: number): void;
    tan(n: number): number;
    test(x: number, y: number): number;
    testr(x: number, y: number): number;
    time(): number;
    troff(): void;
    tron(): void;
    unt(n: number): number;
    upper$(s: string): string;
    using(sFormat: string, ...aArgs: any[]): string;
    vmVal(s: string): number;
    val(s: string): number;
    vpos(iStream: number): number;
    wait(iPort: number, iMask: number, iInv?: number): void;
    width(iWidth: number): void;
    window(iStream: number, iLeft: number, iRight: number, iTop: number, iBottom: number): void;
    windowSwap(iStream1: number, iStream2?: number): void;
    write(iStream: number, ...aArgs: any[]): void;
    xpos(): number;
    ypos(): number;
    zone(n: number): void;
}
export {};
