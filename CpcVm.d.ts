import { CustomError } from "./Utils";
import { Keyboard } from "./Keyboard";
import { Sound, SoundData } from "./Sound";
import { Canvas } from "./Canvas";
import { Variables, VariableMap } from "./Variables";
import { ICpcVmRsx } from "./Interfaces";
interface CpcVmOptions {
    canvas: Canvas;
    keyboard: Keyboard;
    sound: Sound;
    variables: Variables;
    tron: boolean;
}
export interface FileMeta {
    sType: string;
    iStart?: number;
    iLength?: number;
    iEntry?: number;
    sEncoding?: string;
}
interface FileBase {
    bOpen: boolean;
    sCommand: string;
    sName: string;
    iLine: number;
    iStart: (number | undefined);
    aFileData: string[];
    fnFileCallback: ((...aArgs: any[]) => void | boolean) | undefined;
}
interface InFile extends FileBase {
    iFirst: number;
    iLast: number;
    sMemorizedExample: string;
}
interface OutFile extends FileBase {
    iStream: number;
    sType: string;
    iLength: number;
    iEntry: number;
}
interface WindowDimensions {
    iLeft: number;
    iRight: number;
    iTop: number;
    iBottom: number;
}
interface WindowData extends WindowDimensions {
    iPos: number;
    iVpos: number;
    bTextEnabled: boolean;
    bTag: boolean;
    bTransparent: boolean;
    bCursorOn: boolean;
    bCursorEnabled: boolean;
    iPen: number;
    iPaper: number;
}
export interface VmBaseParas {
    sCommand: string;
    iStream: number;
    iLine: string | number;
}
export interface VmLineParas extends VmBaseParas {
    iFirst: number;
    iLast: number;
}
export interface VmLineRenumParas extends VmBaseParas {
    iNew: number;
    iOld: number;
    iStep: number;
    iKeep: number;
}
export interface VmFileParas extends VmBaseParas {
    sFileMask: string;
    sNew?: string;
    sOld?: string;
}
export interface VmInputParas extends VmBaseParas {
    sInput: string;
    sMessage: string;
    sNoCRLF?: string;
    aTypes?: string[];
    fnInputCallback: () => boolean;
}
export declare type VmStopParas = VmFileParas | VmInputParas | VmLineParas | VmLineRenumParas;
export interface VmStopEntry {
    sReason: string;
    iPriority: number;
    oParas: VmStopParas;
}
declare type PrintObjectType = {
    type: string;
    args: (string | number)[];
};
declare type DataEntryType = (string | undefined);
export declare class CpcVm {
    private fnOpeninHandler;
    private fnCloseinHandler;
    private fnCloseoutHandler;
    fnLoadHandler: (sInput: string, oMeta: FileMeta) => boolean;
    private fnRunHandler;
    oCanvas: Canvas;
    private oKeyboard;
    private oSound;
    oVariables: Variables;
    private tronFlag;
    private oRandom;
    private oStop;
    private aInputValues;
    private oInFile;
    private oOutFile;
    private iInkeyTimeMs;
    private aGosubStack;
    private aMem;
    private aData;
    private iData;
    private oDataLineIndex;
    aWindow: WindowData[];
    private aTimer;
    private aSqTimer;
    private aSoundData;
    private aCrtcData;
    private iCrtcReg;
    private sPrintControlBuf;
    private iStartTime;
    private lastRnd;
    private iNextFrameTime;
    private iStopCount;
    iLine: string | number;
    private iStartLine;
    private iErrorGotoLine;
    private iErrorResumeLine;
    private iBreakGosubLine;
    private iBreakResumeLine;
    sOut: string;
    private iErr;
    private iErl;
    private bDeg;
    private bTron;
    private iTronLine;
    private iRamSelect;
    private iScreenPage;
    private iMinCharHimem;
    private iMaxCharHimem;
    private iHimem;
    private iMinCustomChar;
    private iTimerPriority;
    private iZone;
    iMode: number;
    rsx?: ICpcVmRsx;
    private static iFrameTimeMs;
    private static iTimerCount;
    private static iSqTimerCount;
    static iStreamCount: number;
    private static iMinHimem;
    private static iMaxHimem;
    private static oEmptyParas;
    static mWinData: {
        iLeft: number;
        iRight: number;
        iTop: number;
        iBottom: number;
    }[];
    private static mUtf8ToCpc;
    private static aControlCodeParameterCount;
    private static aErrors;
    private static mStopPriority;
    constructor(options: CpcVmOptions);
    vmSetRsxClass(oRsx: ICpcVmRsx): void;
    vmReset(): void;
    vmResetTimers(): void;
    vmResetWindowData(bResetPenPaper: boolean): void;
    vmResetControlBuffer(): void;
    static vmResetFileHandling(oFile: FileBase): void;
    vmResetData(): void;
    private vmResetInks;
    vmReset4Run(): void;
    vmGetAllVariables(): VariableMap;
    vmSetStartLine(iLine: number): void;
    vmOnBreakContSet(): boolean;
    vmOnBreakHandlerActive(): number;
    vmEscape(): boolean;
    private vmAssertNumber;
    private vmAssertString;
    vmRound(n: number | undefined, sErr?: string): number;
    vmInRangeRound(n: number | undefined, iMin: number, iMax: number, sErr?: string): number;
    vmDetermineVarType(sVarType: string): string;
    vmAssertNumberType(sVarType: string): void;
    vmAssign(sVarType: string, value: string | number): (string | number);
    vmGotoLine(line: string | number, sMsg?: string): void;
    private fnCheckSqTimer;
    private vmCheckTimer;
    private vmCheckTimerHandlers;
    private vmCheckSqTimerHandlers;
    private vmCheckNextFrame;
    vmGetTimeUntilFrame(iTime?: number): number;
    vmLoopCondition(): boolean;
    private vmInitUntypedVariables;
    private vmDefineVarTypes;
    vmStop(sReason: string, iPriority: number, bForce?: boolean, oParas?: VmStopParas): void;
    vmNotImplemented(sName: string): void;
    private vmUsingFormat1;
    vmGetStopObject(): VmStopEntry;
    vmGetInFileObject(): InFile;
    vmGetOutFileObject(): OutFile;
    vmAdaptFilename(sName: string, sErr: string): string;
    vmGetSoundData(): SoundData[];
    vmTrace(iLine: number): void;
    private vmDrawMovePlot;
    private vmAfterEveryGosub;
    private vmCopyFromScreen;
    private vmCopyToScreen;
    private vmSetScreenBase;
    private vmSetScreenOffset;
    private vmSetTransparentMode;
    abs(n: number): number;
    addressOf(sVar: string): number;
    afterGosub(iInterval: number, iTimer: number, iLine: number): void;
    private static vmGetCpcCharCode;
    asc(s: string): number;
    atn(n: number): number;
    auto(): void;
    bin$(n: number, iPad?: number): string;
    border(iInk1: number, iInk2?: number): void;
    private vmMcSetMode;
    private vmTxtInverse;
    private vmPutKeyInBuffer;
    call(iAddr: number): void;
    cat(): void;
    chain(sName: string, iLine?: number): void;
    chainMerge(sName: string, iLine?: number, iFirst?: number, iLast?: number): void;
    chr$(n: number): string;
    cint(n: number): number;
    clear(): void;
    clearInput(): void;
    clg(iGPaper?: number): void;
    vmCloseinCallback(): void;
    closein(): void;
    vmCloseoutCallback(): void;
    closeout(): void;
    cls(iStream: number): void;
    commaTab(iStream: number): string;
    cont(): void;
    copychr$(iStream: number): string;
    cos(n: number): number;
    creal(n: number): number;
    vmPlaceRemoveCursor(iStream: number): void;
    vmDrawUndrawCursor(iStream: number): void;
    cursor(iStream: number, iCursorOn?: number, iCursorEnabled?: number): void;
    data(iLine: number, ...aArgs: DataEntryType[]): void;
    dec$(n: number, sFrmt: string): string;
    defint(sNameOrRange: string): void;
    defreal(sNameOrRange: string): void;
    defstr(sNameOrRange: string): void;
    deg(): void;
    "delete"(iFirst?: number, iLast?: number): void;
    derr(): number;
    di(): void;
    dim(sVarName: string): void;
    draw(x: number, y: number, iGPen?: number, iGColMode?: number): void;
    drawr(x: number, y: number, iGPen?: number, iGColMode?: number): void;
    edit(iLine: number): void;
    ei(): void;
    end(sLabel: string): void;
    ent(iToneEnv: number, ...aArgs: number[]): void;
    env(iVolEnv: number, ...aArgs: number[]): void;
    eof(): number;
    private vmFindArrayVariable;
    erase(...aArgs: string[]): void;
    erl(): number;
    err(): number;
    vmComposeError(oError: Error, iErr: number, sErrInfo: string): CustomError;
    error(iErr: number, sErrInfo: string): void;
    everyGosub(iInterval: number, iTimer: number, iLine: number): void;
    exp(n: number): number;
    fill(iGPen: number): void;
    fix(n: number): number;
    frame(): void;
    fre(): number;
    gosub(retLabel: string | number, n: number): void;
    "goto"(n: string): void;
    graphicsPaper(iGPaper: number): void;
    graphicsPen(iGPen?: number, iTransparentMode?: number): void;
    hex$(n: number, iPad?: number): string;
    himem(): number;
    ink(iPen: number, iInk1: number, iInk2?: number): void;
    inkey(iKey: number): number;
    inkey$(): string;
    inp(iPort: number): number;
    vmSetInputValues(aInputValues: (string | number)[]): void;
    vmGetNextInput(): string | number | undefined;
    vmInputCallback(): boolean;
    private fnFileInputGetString;
    private fnFileInputGetNumber;
    private vmInputNextFileItem;
    vmInputFromFile(aTypes: string[]): void;
    input(iStream: number, sNoCRLF: string, sMsg: string): void;
    instr(p1: string | number, p2: string, p3?: string): number;
    "int"(n: number): number;
    joy(iJoy: number): number;
    key(iToken: number, s: string): void;
    keyDef(iCpcKey: number, iRepeat: number, iNormal?: number | undefined, iShift?: number | undefined, iCtrl?: number): void;
    left$(s: string, iLen: number): string;
    len(s: string): number;
    vmLineInputCallback(): boolean;
    lineInput(iStream: number, sNoCRLF: string, sMsg: string, sVarType: string): void;
    list(iStream: number, iFirst?: number, iLast?: number): void;
    vmLoadCallback(sInput: string, oMeta: FileMeta): boolean;
    load(sName: string, iStart?: number): void;
    vmLocate(iStream: number, iPos: number, iVpos: number): void;
    locate(iStream: number, iPos: number, iVpos: number): void;
    log(n: number): number;
    log10(n: number): number;
    private static fnLowerCase;
    lower$(s: string): string;
    mask(iMask: number | undefined, iFirst?: number): void;
    max(...aArgs: number[]): number;
    memory(n: number): void;
    merge(sName: string): void;
    mid$(s: string, iStart: number, iLen?: number): string;
    mid$Assign(s: string, iStart: number, iLen: number | undefined, sNew: string): string;
    min(...aArgs: number[]): number;
    mode(iMode: number): void;
    move(x: number, y: number, iGPen?: number, iGColMode?: number): void;
    mover(x: number, y: number, iGPen?: number, iGColMode?: number): void;
    "new"(): void;
    onBreakCont(): void;
    onBreakGosub(iLine: number): void;
    onBreakStop(): void;
    onErrorGoto(iLine: number): void;
    onGosub(retLabel: string, n: number, ...aArgs: number[]): void;
    onGoto(retLabel: string, n: number, ...aArgs: number[]): void;
    private static fnChannel2ChannelIndex;
    onSqGosub(iChannel: number, iLine: number): void;
    vmOpeninCallback(sInput: string | null): void;
    openin(sName: string): void;
    openout(sName: string): void;
    origin(xOff: number, yOff: number, xLeft?: number, xRight?: number, yTop?: number, yBottom?: number): void;
    vmSetRamSelect(iBank: number): void;
    vmSetCrtcData(iByte: number): void;
    out(iPort: number, iByte: number): void;
    paper(iStream: number, iPaper: number): void;
    vmGetCharDataByte(iAddr: number): number;
    vmSetCharDataByte(iAddr: number, iByte: number): void;
    peek(iAddr: number): number;
    pen(iStream: number, iPen: number | undefined, iTransparent?: number): void;
    pi(): number;
    plot(x: number, y: number, iGPen?: number, iGColMode?: number): void;
    plotr(x: number, y: number, iGPen?: number, iGColMode?: number): void;
    poke(iAddr: number, iByte: number): void;
    pos(iStream: number): number;
    private vmGetAllowedPosOrVpos;
    private vmMoveCursor2AllowedPos;
    private vmPrintChars;
    private vmControlSymbol;
    private vmControlWindow;
    private vmHandleControlCode;
    private vmPrintCharsOrControls;
    private vmPrintGraphChars;
    print(iStream: number, ...aArgs: (string | number | PrintObjectType)[]): void;
    rad(): void;
    private static vmHashCode;
    private vmRandomizeCallback;
    randomize(n?: number): void;
    read(sVarType: string): string | number;
    release(iChannelMask: number): void;
    remain(iTimer: number): number;
    renum(iNew?: number, iOld?: number, iStep?: number, iKeep?: number): void;
    restore(iLine?: number): void;
    resume(iLine: number): void;
    resumeNext(): void;
    "return"(): void;
    right$(s: string, iLen: number): string;
    rnd(n: number): number;
    round(n: number, iDecimals?: number): number;
    private vmRunCallback;
    run(numOrString?: number | string): void;
    save(sName: string, sType?: string, iStart?: number, iLength?: number, iEntry?: number): void;
    sgn(n: number): number;
    sin(n: number): number;
    sound(iState: number, iPeriod: number, iDuration?: number, iVolume?: number, iVolEnv?: number, iToneEnv?: number, iNoise?: number): void;
    space$(n: number): string;
    spc(iStream: number, n: number): string;
    speedInk(iTime1: number, iTime2: number): void;
    speedKey(iDelay: number, iRepeat: number): void;
    speedWrite(n: number): void;
    sq(iChannel: number): number;
    sqr(n: number): number;
    stop(sLabel: string): void;
    str$(n: number): string;
    string$(iLen: number, chr: number | string): string;
    symbol(iChar: number, ...aArgs: number[]): void;
    symbolAfter(iChar: number): void;
    tab(iStream: number, n: number): string;
    tag(iStream: number): void;
    tagoff(iStream: number): void;
    tan(n: number): number;
    test(x: number, y: number): number;
    testr(x: number, y: number): number;
    time(): number;
    troff(): void;
    tron(): void;
    unt(n: number): number;
    private static fnUpperCase;
    upper$(s: string): string;
    using(sFormat: string, ...aArgs: (string | number)[]): string;
    private static vmVal;
    val(s: string): number;
    vpos(iStream: number): number;
    wait(iPort: number, iMask: number, iInv?: number): void;
    width(iWidth: number): void;
    window(iStream: number, iLeft: number, iRight: number, iTop: number, iBottom: number): void;
    windowSwap(iStream1: number, iStream2?: number): void;
    write(iStream: number, ...aArgs: (string | number)[]): void;
    xpos(): number;
    ypos(): number;
    zone(n: number): void;
}
export {};
