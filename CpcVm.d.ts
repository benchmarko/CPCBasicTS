import { Keyboard } from "./Keyboard";
import { Random } from "./Random";
import { Sound } from "./Sound";
import { Canvas } from "./Canvas";
import { Variables } from "./Variables";
interface CpcVmOptions {
    canvas: Canvas;
    keyboard: Keyboard;
    sound: Sound;
    variables: Variables;
    tron: boolean;
}
interface FileBase {
    bOpen: boolean;
    sCommand: string;
    sName: string;
    iLine: number;
    iStart: number;
    aFileData: string[];
    fnFileCallback: (...aArgs: any[]) => void | boolean;
}
interface InFile extends FileBase {
    iFirst: number;
    iLast: number;
    sMemorizedExample: string;
}
interface OutFile extends FileBase {
    iStream: number;
    sType: string;
    iLength: number;
    iEntry: number;
}
export interface StopParas {
    iStream?: number;
    sMessage?: string;
    fnInputCallback?: any;
    sInput?: string;
    iLine?: string | number;
    sCommand?: string;
    sNoCRLF?: string;
    aTypes?: string[];
    iFirst?: number;
    iLast?: number;
    iNew?: number;
    iOld?: number;
    iStep?: number;
    iKeep?: number;
    sFileMask?: string;
    sNew?: string;
    sOld?: string;
}
export interface StopEntry {
    sReason: string;
    iPriority: number;
    oParas?: StopParas;
}
export declare class CpcVm {
    fnOpeninHandler: FileBase["fnFileCallback"];
    fnCloseinHandler: any;
    fnCloseoutHandler: any;
    fnLoadHandler: any;
    fnRunHandler: any;
    options: CpcVmOptions;
    oCanvas: Canvas;
    oKeyboard: Keyboard;
    oSound: Sound;
    oVariables: Variables;
    tronFlag: boolean;
    oRandom: Random;
    oStop: StopEntry;
    aInputValues: (string | number)[];
    oInFile: InFile;
    oOutFile: OutFile;
    iInkeyTime: number;
    aGosubStack: any[];
    aMem: any[];
    aData: any[];
    iData: number;
    oDataLineIndex: {
        0: number;
    };
    aWindow: any[];
    aTimer: any[];
    aSoundData: any[];
    aSqTimer: any[];
    aCrtcData: any[];
    sPrintControlBuf: string;
    iStartTime: number;
    lastRnd: number;
    iNextFrameTime: number;
    iTimeUntilFrame: number;
    iStopCount: number;
    iLine: string | number;
    iStartLine: number;
    iErrorGotoLine: number;
    iErrorResumeLine: number;
    iBreakGosubLine: number;
    iBreakResumeLine: number;
    sOut: string;
    iErr: number;
    iErl: string | number;
    bDeg: boolean;
    bTron: boolean;
    iTronLine: number;
    iRamSelect: number;
    iScreenPage: number;
    iCrtcReg: number;
    iMinCharHimem: number;
    iMaxCharHimem: number;
    iHimem: number;
    iMinCustomChar: number;
    iTimerPriority: number;
    iZone: number;
    iMode: number;
    iInkeyTimeMs: number;
    rsx: object;
    constructor(options: CpcVmOptions);
    static iFrameTimeMs: number;
    static iTimerCount: number;
    static iSqTimerCount: number;
    static iStreamCount: number;
    static iMinHimem: number;
    static iMaxHimem: number;
    static mWinData: {
        iLeft: number;
        iRight: number;
        iTop: number;
        iBottom: number;
    }[];
    static mUtf8ToCpc: {
        8364: number;
        8218: number;
        402: number;
        8222: number;
        8230: number;
        8224: number;
        8225: number;
        710: number;
        8240: number;
        352: number;
        8249: number;
        338: number;
        381: number;
        8216: number;
        8217: number;
        8220: number;
        8221: number;
        8226: number;
        8211: number;
        8212: number;
        732: number;
        8482: number;
        353: number;
        8250: number;
        339: number;
        382: number;
        376: number;
    };
    private static mControlCodeParameterCount;
    private static aErrors;
    vmInit(options: CpcVmOptions): void;
    vmSetRsxClass(oRsx: object): void;
    vmReset(): void;
    vmResetTimers(): void;
    vmResetWindowData(bResetPenPaper: boolean): void;
    vmResetControlBuffer(): void;
    vmResetFileHandling(oFile: FileBase): void;
    vmResetData(): void;
    vmResetInks(): void;
    vmReset4Run(): void;
    vmGetAllVariables(): {
        [x: string]: string | number | object;
    };
    vmSetStartLine(iLine: any): void;
    vmOnBreakContSet(): boolean;
    vmOnBreakHandlerActive(): number;
    vmEscape(): boolean;
    vmAssertNumber(n: number, sErr: string): void;
    vmAssertString(s: string, sErr: string): void;
    vmRound(n: number, sErr?: string): number;
    vmInRangeRound(n: number, iMin: number, iMax: number, sErr?: string): number;
    vmDetermineVarType(sVarType: string): string;
    vmAssertNumberType(sVarType: string): void;
    vmAssign(sVarType: string, value: string | number): (string | number);
    vmGotoLine(line: string | number, sMsg?: string): void;
    private fnCheckSqTimer;
    private vmCheckTimer;
    private vmCheckTimerHandlers;
    private vmCheckSqTimerHandlers;
    private vmCheckNextFrame;
    vmGetTimeUntilFrame(iTime?: number): number;
    vmLoopCondition(): boolean;
    private vmInitUntypedVariables;
    private vmDefineVarTypes;
    vmStop(sReason: string, iPriority: number, bForce?: boolean, oParas?: StopParas): void;
    vmNotImplemented(sName: string): void;
    vmUsingFormat1(sFormat: string, arg: any): string;
    vmGetStopObject(): StopEntry;
    vmGetInFileObject(): InFile;
    vmGetOutFileObject(): OutFile;
    vmAdaptFilename(sName: string, sErr: string): string;
    vmGetSoundData(): any[];
    vmTrace(iLine: any): void;
    vmDrawMovePlot(sType: string, x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    private vmAfterEveryGosub;
    private vmCopyFromScreen;
    private vmCopyToScreen;
    private vmSetScreenBase;
    private vmSetScreenOffset;
    private vmSetTransparentMode;
    abs(n: number): number;
    addressOf(sVar: string): number;
    afterGosub(iInterval: number, iTimer: number, iLine: number): void;
    private static vmGetCpcCharCode;
    asc(s: string): number;
    atn(n: number): number;
    auto(): void;
    bin$(n: number, iPad?: number): string;
    border(iInk1: number, iInk2?: number): void;
    private vmMcSetMode;
    private vmTxtInverse;
    private vmPutKeyInBuffer;
    call(iAddr: number): void;
    cat(): void;
    chain(sName: string, iLine: any): void;
    chainMerge(sName: string, iLine: any, iFirst: number, iLast: number): void;
    chr$(n: number): string;
    cint(n: number): number;
    clear(): void;
    clearInput(): void;
    clg(iGPaper?: number): void;
    vmCloseinCallback(): void;
    closein(): void;
    vmCloseoutCallback(): void;
    closeout(): void;
    cls(iStream?: number): void;
    commaTab(iStream: number): string;
    cont(): void;
    copychr$(iStream: number): string;
    cos(n: number): number;
    creal(n: number): number;
    vmPlaceRemoveCursor(iStream: number): void;
    vmDrawUndrawCursor(iStream: number): void;
    cursor(iStream: number, iCursorOn: number | null, iCursorEnabled?: number): void;
    data(iLine: number, ...aArgs: any[]): void;
    dec$(n: number, sFrmt: string): string;
    defint(sNameOrRange: string): void;
    defreal(sNameOrRange: string): void;
    defstr(sNameOrRange: string): void;
    deg(): void;
    "delete"(iFirst?: number | null, iLast?: number): void;
    derr(): number;
    di(): void;
    dim(sVarName: string): void;
    draw(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    drawr(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    edit(iLine: any): void;
    ei(): void;
    end(sLabel: string): void;
    ent(iToneEnv: number, ...aArgs: any[]): void;
    env(iVolEnv: number, ...aArgs: any[]): void;
    eof(): number;
    vmFindArrayVariable(sName: string): string;
    erase(...aArgs: string[]): void;
    erl(): number;
    err(): number;
    vmComposeError(oError: any, iErr: number, sErrInfo: string): import("./Utils").CustomError;
    error(iErr: number, sErrInfo: string): void;
    everyGosub(iInterval: number, iTimer: number, iLine: number): void;
    exp(n: number): number;
    fill(iGPen: number): void;
    fix(n: number): number;
    frame(): void;
    fre(): number;
    gosub(retLabel: string | number, n: number): void;
    "goto"(n: string): void;
    graphicsPaper(iGPaper: number): void;
    graphicsPen(iGPen: number | null, iTransparentMode?: number): void;
    hex$(n: number, iPad?: number): string;
    himem(): number;
    ink(iPen: number, iInk1: number, iInk2?: number): void;
    inkey(iKey: number): number;
    inkey$(): string;
    inp(iPort: number): number;
    vmSetInputValues(aInputValues: (string | number)[]): void;
    vmGetNextInput(): string | number;
    vmInputCallback(): boolean;
    vmInputNextFileItem(sType: string): any;
    vmInputFromFile(aTypes: string[]): void;
    input(iStream: number, sNoCRLF: string, sMsg: string): void;
    instr(p1: string | number, p2: string, p3?: string): number;
    "int"(n: number): number;
    joy(iJoy: number): number;
    key(iToken: number, s: string): void;
    keyDef(iCpcKey: number, iRepeat: number, iNormal?: number | null, iShift?: number | null, iCtrl?: number): void;
    left$(s: string, iLen: number): string;
    len(s: string): number;
    vmLineInputCallback(): boolean;
    lineInput(iStream: number | null, sNoCRLF: string, sMsg: string, sVarType: string): void;
    list(iStream: number | null, iFirst?: number, iLast?: number): void;
    vmLoadCallback(sInput: string, oMeta: any): boolean;
    load(sName: string, iStart: number): void;
    vmLocate(iStream: number, iPos: number, iVpos: number): void;
    locate(iStream: number, iPos: number, iVpos: number): void;
    log(n: number): number;
    log10(n: number): number;
    lower$(s: string): string;
    mask(iMask: number | null, iFirst?: number): void;
    max(...aArgs: number[]): number;
    memory(n: number): void;
    merge(sName: string): void;
    mid$(s: string, iStart: number, iLen?: number): string;
    mid$Assign(s: string, iStart: number, iLen: number | null, sNew: string): string;
    min(...aArgs: number[]): number;
    mode(iMode: number): void;
    move(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    mover(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    "new"(): void;
    onBreakCont(): void;
    onBreakGosub(iLine: any): void;
    onBreakStop(): void;
    onErrorGoto(iLine: any): void;
    onGosub(retLabel: string, n: number, ...aArgs: number[]): void;
    onGoto(retLabel: string, n: number, ...aArgs: number[]): void;
    private fnChannel2ChannelIndex;
    onSqGosub(iChannel: number, iLine: any): void;
    vmOpeninCallback(sInput: string | null): void;
    openin(sName: string): void;
    openout(sName: string): void;
    origin(xOff: number, yOff: number, xLeft?: number, xRight?: number, yTop?: number, yBottom?: number): void;
    vmSetRamSelect(iBank: number): void;
    vmSetCrtcData(iByte: number): void;
    out(iPort: number, iByte: number): void;
    paper(iStream: number | null, iPaper: number): void;
    vmGetCharDataByte(iAddr: number): any;
    vmSetCharDataByte(iAddr: any, iByte: any): void;
    peek(iAddr: any): any;
    pen(iStream: number, iPen: number | null, iTransparent?: number): void;
    pi(): number;
    plot(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    plotr(x: number, y: number, iGPen?: number | null, iGColMode?: number): void;
    poke(iAddr: any, iByte: any): void;
    pos(iStream: any): any;
    vmGetAllowedPosOrVpos(iStream: any, bVpos: any): any;
    vmMoveCursor2AllowedPos(iStream: number): void;
    vmPrintChars(iStream: any, sStr: any): void;
    vmControlSymbol(sPara: any): void;
    vmControlWindow(sPara: any, iStream: any): void;
    vmHandleControlCode(iCode: any, sPara: any, iStream: any): string;
    vmPrintCharsOrControls(iStream: number, sStr: string, sBuf?: string): string;
    vmPrintGraphChars(sStr: string): void;
    print(iStream: any, ...aArgs: any[]): void;
    rad(): void;
    vmHashCode(s: any): number;
    vmRandomizeCallback(): boolean;
    randomize(n: any): void;
    read(sVarType: any): string | number;
    release(iChannelMask: any): void;
    remain(iTimer: any): number;
    renum(iNew: any, iOld: any, iStep: any, iKeep: any): void;
    restore(iLine?: number): void;
    resume(iLine: any): void;
    resumeNext(): void;
    "return"(): void;
    right$(s: string, iLen: number): string;
    rnd(n: number): any;
    round(n: any, iDecimals: any): number;
    private vmRunCallback;
    run(numOrString: any): void;
    save(sName: any, sType: any, iStart: any, iLength: any, iEntry: any): void;
    sgn(n: any): number;
    sin(n: any): number;
    sound(iState: any, iPeriod: any, iDuration: any, iVolume: any, iVolEnv: any, iToneEnv: any, iNoise: any): void;
    space$(n: any): string;
    spc(iStream: any, n: any): string;
    speedInk(iTime1: any, iTime2: any): void;
    speedKey(iDelay: any, iRepeat: any): void;
    speedWrite(n: any): void;
    sq(iChannel: any): any;
    sqr(n: any): number;
    stop(sLabel: any): void;
    str$(n: any): any;
    string$(iLen: any, chr: any): any;
    symbol(iChar: any): void;
    symbolAfter(iChar: any): void;
    tab(iStream: any, n: any): string;
    tag(iStream: any): void;
    tagoff(iStream: any): void;
    tan(n: any): number;
    test(x: any, y: any): number;
    testr(x: any, y: any): number;
    time(): number;
    troff(): void;
    tron(): void;
    unt(n: any): any;
    upper$(s: any): any;
    using(sFormat: any): string;
    vmVal(s: any): number;
    val(s: any): any;
    vpos(iStream: any): any;
    wait(iPort: any, iMask: any, iInv: any): void;
    width(iWidth: any): void;
    window(iStream: any, iLeft: any, iRight: any, iTop: any, iBottom: any): void;
    windowSwap(iStream1: any, iStream2: any): void;
    write(iStream: any): void;
    xpos(): number;
    ypos(): number;
    zone(n: any): void;
}
export {};
